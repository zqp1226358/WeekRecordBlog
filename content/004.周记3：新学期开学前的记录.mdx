---
title: 周记3：新学期开学前的记录
slug: 2025-02-16-001
date: 2025-02-16
---

从放假到现在，看了JVM、JUC、Mysql这三块的内容，重新看又有了新的理解，假期比较懈怠，希望后续把欠的内容补回来。

内容总结如下：

## 1. 阅读JVM的内容
JVM 运行时数据区域，书中没有说清楚的方法区、永久代、元空间
● 程序计数器是线程私有的，不会出现内存溢出。
● 就是说一个线程运行，栈会分配一定空间给这个线程，这段空间由由多个栈帧构成，每个栈帧对应一个对象方法
● 1.8之前用的是永久代，占用堆内存的一部分。1.8 之后用的是metaspace是操作系统的内存，因为方法区的大小不好估量,所以转到(元空间)本地内存,这样堆就好优化了。永久代和元空间最本质的区别就是 前者使用的是jvm内存 后者使用的是操作系统内存。
● 直接内存jvm可以访问，系统内存也可以访问，减少一次数据的重复拷贝
● 强：用到不回收；软：没用到不回收，内存满了回收；弱：被发现就被回收，虚：弱+引用队列
● jvm参数  调整桶的个数 越大越快    还有就是晋升阈值
● 当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行
● class文件常量信息会被载入到运行时常量池，对于数字而言，小于Short类型最大值会存放到字节码指令，反之则放入运行时常量池
● 看到了类加载那部分，后续再继续看完

## 2. 阅读Java并发的内容
观看了黑马满老师的并发课程的第8章线程池的内容
● 首先尝试实现一个自定义线程池，大致框架是执行区域和一个阻塞队列，体验到线程池的构造原理。
● 查看JDK中ThreadPoolExecutor的构造方法，比起自定义的多了一个叫救济线程的东西，将其联系起来。
● 进而学习了Executors工具类帮我们实现了的三类线程池，固定大小线程池、带缓冲线程池、单线程线程池。都是已经使用ThreadPoolExecutor的构造方法来实现，注意他们的优缺点，阻塞队列的选用。（阻塞队列中大小为int的max_value，相当于无界不可达）（根据阿里手册，推荐使用自定义线程池的方式去实现）
● 然后学习一些ThreadPoolExecutor的api，比如如何执行和停止，submit和excute的区别，invokeall和invokeAny
● 设计模式--工作线程---饥饿相关的问题 （好像不是太重要）
● 下面讲解了定时的线程池的使用，首先通过Timer的缺点，引入ScheduledThreadPoolExecutor线程池，根据弹幕，这个只适合单体，如果是springboot可以使用cor注解，分布式的话可以采用xxxjob来解决。
● tomcat线程池的配置
● forkjoin的使用   （任务拆分优化)  （不太get这个东西的作用）
● 到此线程池的内容结束，下面是并发相关的锁的内容。
● 首先是AQS的内容讲解，这个是后续锁实现的基石，都是一个内部类去继承aqs。
● 可重入锁reentranlock  （可重入的原理---非公平锁与公平锁----可打断原理 这个没看懂----条件变量）
● 读写锁：可重入读写锁reentrantreadwritelock和stampedlock  
● semaphore信号量
● countdownlatch和cyclicbarrier，像lock我们可以理解为小锁，latch栏栅这种就好比一大堆线程过来，然后再进行一些操作。
countdownLatch 可以配合线程池使用，是高级Api，与之前join的区别，join虽然也可以完成相关功能，但作为底层，使用起来较为麻烦。
cyclicBarrier 可重复  建议数量和线程池数量一致。
● 到此并发相关的锁内容结束，下面是线程安全集合类的内容。
● 线程安全集合 三大类  遗留的（hashtable和vector)；集合类；JUC。其中JUC主要分三大类：  Blocking；CopyOnWrite；Concurrent
● 在使用一些安全集合的时候，比如可以结合前面学的LongAdder来进行安全累加。
到此JUC视频结束，对于一些原理内容进行了跳过，后续再补充。根据视频后续应当还有异步编程的内容，感觉就是把Future换成CompleteFuture，好像jdk8新特性，待补充。

## 3. 学习回顾数据库的内容
首先知道mysql默认使用的存储引擎是innodb，然后重点是关于索引的部分，innodb默认索引结构是B+Tree，我们通常按照索引类型分为主键索引，唯一索引，常规索引，全文索引。在inodb中，根据索引的存储形式又可以分为聚集索引和二级索引。
聚集索引一般就是主键索引（如果主键存在），叶子节点放的是行数据。
二级索引叶子节点放的则是主键，如果select数据有多余项，还会涉及回表查询，尽量使用覆盖索引。
了解一些性能分析的工具，主要是explian。
多多使用联合索引，相较于单列索引。
注意最左前缀匹配法则。where和order by一些区别。
注意一些索引失效的情况。
跳过了视图、存储过程、触发器那一个章节。
然后就是锁，全局锁、表锁、行锁
最后就是inodb引擎，主要是MVCC原理，这也是可重复读的原因。
数据库优化器可能会使用一种称为“索引下推”（index condition pushdown）的技术。这种技术允许数据库在索引遍历过程中对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表
DML语句和for update会给表加上意向锁，同时会给索引添加行锁